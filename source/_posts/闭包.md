---
title: 闭包
date: 2022-01-06 16:30:36
tags:
---
***

### 什么是闭包
**闭包**是有权访问另一个函数作用域中变量的函数

### 闭包变量存储的位置
闭包中的变量存储的位置是堆内存。

+ 假如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。


### 闭包的作用
+ 保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。
+ 保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化。

### 闭包的应用场景
闭包常被见于实现单例模式、柯里化、防抖、节流、模块化

1.单例模式
``` 
  function singleIns(name) {
    this.name = name;
  }
  singleIns.getInstance = (function () {
    var instance = null;
    return function (name) {
      if (!this.instance) {
        this.instance = new singleIns(name);
      }
      return this.instance;
    };
  })();
  var a = singleIns.getInstance("a");
  var b = singleIns.getInstance("b");
  a === b; // true

```
2.柯里化
```
function curry(func) {
  return function curried(...args) {
    if (args.length >= func.length) {
      func.apply(this, args);
    } else {
      return function (...args2) {
        curried.apply(this, args.concat(args2));
      };
    }
  };
}
// example
function a(x, y, z) {
  console.log(x + y + z);
}
var b = curry(a);
b(1, 2, 3); // 6
b(1, 2)(3); // 6
b(1)(2, 3); // 6
b(1)(2)(3); // 6

```

3.防抖节流
```
// 节流
function throttle(fn, timeout) {
    let timer = null
    return function (...arg) {
        if(timer) return
        timer = setTimeout(() => {
            fn.apply(this, arg)
            timer = null
        }, timeout)
    }
}

// 防抖
function debounce(fn, timeout){
    let timer = null
    return function(...arg){
        clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(this, arg)
        }, timeout)
    }
}

```

### 使用闭包需要注意什么
容易导致内存泄漏。闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。

***


<!-- [typera](https://www.typora.net/527.html) -->
